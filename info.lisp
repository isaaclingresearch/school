;;; this defines the application for handling general school information.
;;; general school information means the basic structure of the school.

;;; TOOD use foreign keys in the tables to ensure data integrity
(defpackage :school-info
  (:use :cl :ltk :sqlite)
  (:export :start :create-tables))

(in-package :school-info)

(defparameter *school-info-main-frame* nil)		

;; defines the sqlite3 database used by the application.
(defparameter *db* (connect  (uiop:native-namestring "~/common-lisp/school/db/school.db")))

;; DB ACCESS FUNCTIONS

(defun create-tables ()
  (execute-non-query *db* "create table levels (id integer primary key, level text uniqueE, added_on default current_timestamp)")
  (execute-non-query *db* "create table classes (id integer primary key, class text unique,  level_id integer, added_on default current_timestamp, foreign key (level_id) references levels (id))")
  (execute-non-query *db* "create table streams (id integer primary key, class_id integer, stream text unique, added_on default current_timestamp, foreign key (class_id) references classes (id))")
  (execute-non-query *db* "create table houses (id integer primary key, house text unique, added_on default current_timestamp)")
  (execute-non-query *db* "create table dorms (id integer primary key, dorm text unique, added_on default current_timestamp)")
  ;; use stream is to ensure uniqueness as different classes can have the same stream
  (execute-non-query *db* "create table subjects (id integer primary key, subject text unique, stream_id integer, added_on default current_timestamp, foreign key (stream_id) references streams (id))")
  )

;; define macros to define the following functions for single entry forms
(defmacro intern-name (var1 type)
  (let ((action (case type
		  (:get "get-~a")
		  (:get-id "get-~a-id")
		  (:delete "delete-~a")
		  (:save "save-~a")
		  (:update "update-~a"))))
    `(intern (format nil ,action ,var1))))

(defmacro make-functions-1 (name table)
  `(progn
     (defun ,(intern-name name :get) ()
       (execute-to-list *db* (format nil "select id, ~a from ~a" ,name ,table)))
     (defun ,(intern-name name :get-id) (datum)
       (caar (execute-to-list *db* (format nil "select id from ~a where ~a = ?" ,table ,name) datum)))
     (defun ,(intern-name name :save) (datum)
       (execute-non-query *db* (format nil "insert into ~a (~a) values (?)" ,table ,name) datum))
     (defun ,(intern-name name :update) (id new-datum)
       (execute-non-query *db* (format nil "update ~a set ~a = ? where id = ?" ,table ,name) new-datum id))
     (defun ,(intern-name name :delete) (id)
       (execute-non-query *db* (format nil "delete from ~a where id = ?" ,table) id))))

(make-functions-1 "level" "levels")
(make-functions-1 "house" "houses")
(make-functions-1 "dorm" "dorms")

;; CLASS FUNCTIONS
(defun get-classes (&optional level-id)
  (if level-id
      (execute-to-list *db* "select class, id from classes where level_id = ?" level-id)
      (execute-to-list *db* "select class, level_id from classes")))

(defun get-class-id (class)
  (caar (execute-to-list *db* "select id from classes where class = ?" class)))

(defun get-class-name (class-id)
  (caar (execute-to-list *db* "select class from classes where id = ?" class-id)))

(defun save-class (level-id class)
  (execute-non-query *db* "insert into classes (level_id, class) values (?, ?)" level-id class))

(defun update-class (level-id class new-class)
  (execute-non-query *db* "update classes set class = ? where class = ? and level_id = ?" new-class class level-id))

(defun delete-class (level-id class)
  (execute-non-query *db* "delete from classes where level_id = ? and class = ?" level-id class))

(defun iconbitmap (path-to-icon)		
  (format-wish "wm iconbitmap . ~a" path-to-icon))					

;; STREAM FUNCTIONS
(defun get-streams (&optional class-id)
  (if class-id
      (execute-to-list *db* "select stream, id, class_id from streams where class_id = ?" class-id)
      (execute-to-list *db* "select stream, class_id, id from streams")))

(defun save-stream (class-id stream)
  (execute-non-query *db* "insert into streams (class_id, stream) values (?, ?)" class-id stream))

(defun update-stream (class-id stream new-stream)
  (execute-non-query *db* "update streams set stream = ? where class_id = ? and stream = ?" new-stream class-id stream))

(defun delete-stream (class-id stream)
  (execute-non-query *db* "delete from streams where class_id = ? and stream = ?" class-id stream))

;; HOUSE FUNCTIONS
(defun get-houses ()
  (execute-to-list *db* "select id, house from houses"))

(defun save-house (house)
  (execute-non-query *db* "insert into houses (house) values (?)" house))

(defun update-house (id new-house)
  (execute-non-query *db* "update houses set house = ? where id = ?" new-house id))

(defun delete-house (id)
  (execute-non-query *db* "delete from houses where id = ?" id))

;; SUBJECT FUNCTIONS
(defun get-subjects ()
  (execute-to-list *db* "select id, subject, stream_id from subjects"))

(defun get-stream-subjects (stream-id)
  (execute-to-list *db* "select id, subject from subjects where stream_id = ?" stream-id))

(defun save-subject (stream-id subject)
  (execute-non-query *db* "insert into subjects (stream_id, subject) values (?, ?)" stream-id subject))

(defun update-subject (subject-id subject)
  (execute-non-query *db* "update subjects set subject = ? where id = ?" subject subject-id))

(defun delete-subject (subject-id)
  (execute-non-query *db* "delete from subjects where id = ?" subject-id))

(defun iconbitmap (path-to-icon)		
  (format-wish "wm iconbitmap . ~a" path-to-icon))					

(defparameter *menubar* nil)

(defun prepare-main-window ()
  (grid *school-info-main-frame* 0 0)
  (grid-columnconfigure *tk* 0 :weight 1) 
  (grid-rowconfigure *tk* 0 :weight 1))

(defun level-menu (level-menu)
  "defines the functions that display the level menu on the menubar"
  (make-instance 'menubutton :master level-menu :text "New" :command (lambda () (level-form)))
  (let ((edit-level-menu (make-instance 'menu :master level-menu :text "Edit"))
	(delete-level-menu (make-instance 'menu :master level-menu :text "Delete"))
	(levels (|get-level|)))
    (dolist (level levels)
      (make-instance 'menubutton :master edit-level-menu :text (cadr level) :command (lambda () (level-form level)))
      (make-instance 'menubutton :master delete-level-menu :text (cadr level)
				 :command (lambda ()
					    (let ((message-text "Level has been deleted."))
					      (handler-case (|delete-level| (car level))
						(sqlite-constraint-error (err)
						  (declare (ignorable err))
						  (setq message-text "Level can't be deleted as it has classes, first delete them and try again.")))
					      (create-menubar)
					      (grid-columnconfigure *tk* 0 :weight 1) 
					      (grid-rowconfigure *tk* 0 :weight 1)
					      (destroy *school-info-main-frame*)
					      (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
					      (grid *school-info-main-frame* 0 0)
					      (grid (make-instance 'label :master *school-info-main-frame* :text message-text) 1 0)))))))

(defun class-menu (class-menu)
  (make-instance 'menubutton :master class-menu :text "New" :command (lambda () (class-form)))
  (let ((edit-menu (make-instance 'menu :master class-menu :text "Edit"))
	(delete-menu (make-instance 'menu :master class-menu :text "Delete"))
	(levels (|get-level|)))
    (dolist (level levels)
      (let* ((edit-level-menu (make-instance 'menu :master edit-menu :text (cadr level)))
	     (delete-level-menu (make-instance 'menu :master delete-menu :text (cadr level)))
	     (classes (get-classes (car level))))
	(dolist (class classes)
	  (make-instance 'menubutton :master edit-level-menu :text (car class) :command (lambda () (class-form (car level) (car class))))
	  (make-instance 'menubutton :master delete-level-menu :text (car class)
				     :command (lambda ()
						(let ((message "The class has been deleted.")) 
						  (handler-case (delete-class (car level) (car class))
						    (sqlite-constraint-error (err)
						      (declare (ignorable err))
						      (setq message "Class can't be as it has streams, first delete them and try again.")))
						  (create-menubar)
						  (grid-columnconfigure *tk* 0 :weight 1) 
						  (grid-rowconfigure *tk* 0 :weight 1)
						  (destroy *school-info-main-frame*)
						  (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
						  (grid *school-info-main-frame* 0 0)
						  (grid (make-instance 'label :master *school-info-main-frame* :text message) 1 0))
						)))))))

(defun stream-menu (stream-menu)  
  (make-instance 'menubutton :master stream-menu :text "New" :command (lambda () (stream-form)))
  (let ((edit-menu (make-instance 'menu :master stream-menu :text "Edit"))
	(delete-menu (make-instance 'menu :master stream-menu :text "Delete"))
	(levels (|get-level|)))
    (dolist (level levels)
      (let* ((classes (get-classes (cadr level))))
	(dolist (class classes)
	  (let* ((edit-class-menu (make-instance 'menu :master edit-menu :text (cadr class)))
		 (delete-class-menu (make-instance 'menu :master delete-menu :text (cadr class)))
		 (streams (get-streams (cadr class))))
	    (dolist (stream streams)
	      (make-instance 'menubutton :master edit-class-menu :text (car stream) :command (lambda () (stream-form (car class) (car stream))))
	      (make-instance 'menubutton :master delete-class-menu :text (car stream)
					 :command (lambda ()
						    (let ((message "The stream has been deleted."))
						      (handler-case (delete-stream (cadr class) (car stream))
							(sqlite-constraint-error (err)
							  (declare (ignorable err))
							  (setq message "The stream can't be deleted as it has subjects, first delete them and try again.")))
						      (create-menubar)
						      (grid-columnconfigure *tk* 0 :weight 1) 
						      (grid-rowconfigure *tk* 0 :weight 1)
						      (destroy *school-info-main-frame*)
						      (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
						      (grid *school-info-main-frame* 0 0)
						      (grid (make-instance 'label :master *school-info-main-frame* :text message) 1 0))
						    )))))))
    ))

(defun subject-menu (subject-menu)
  (let ((new-menu (make-instance 'menu :master subject-menu :text "New"))
	(show-menu (make-instance 'menu :master subject-menu :text "Show"))
	(edit-menu (make-instance 'menu :master subject-menu :text "Edit"))
	(delete-menu (make-instance 'menu :master subject-menu :text "Delete")) 
	(levels (|get-level|)))
    (dolist (level levels)
      (let* ((new-level-menu (make-instance 'menu :master new-menu :text (cadr level)))
	     (edit-level-menu (make-instance 'menu :master edit-menu :text (cadr level)))
	     (show-level-menu (make-instance 'menu :master show-menu :text (cadr level)))
	     (delete-level-menu (make-instance 'menu :master delete-menu :text (cadr level)))
	     (classes (get-classes (car level))))
	(dolist (class classes)
	  (let* ((new-class-menu (make-instance 'menu :master new-level-menu :text (car class)))
		 (edit-class-menu (make-instance 'menu :master edit-level-menu :text (car class)))
		 (show-class-menu (make-instance 'menu :master show-level-menu :text (car class)))
		 (delete-class-menu (make-instance 'menu :master delete-level-menu :text (car class)))
		 (streams (get-streams (cadr class))))
	    (dolist (stream streams)
	      (make-instance 'menubutton :master new-class-menu :text (car stream) :command (lambda () (subject-form stream)))
	      (make-instance 'menubutton :master show-class-menu :text (car stream) :command (lambda () (show-stream-subjects stream)))
	      (let ((subjects (get-stream-subjects (car stream)))
		    (edit-stream-menu (make-instance 'menu :master edit-class-menu :text (cadr stream)))
		    (delete-stream-menu (make-instance 'menu :master delete-class-menu :text (cadr stream))))
		(dolist (subject subjects)
		  (make-instance 'menubutton :master edit-stream-menu :text (cadr subject) :command (lambda () (subject-form stream subject)))
		  (make-instance 'menubutton :master delete-stream-menu :text (cadr subject) :command (lambda ()
													(let ((message "The subject has been deleted"))
													  (handler-case (delete-subject (car subject))
													    (sqlite-constraint-error (err)
													      (declare (ignorable err))
													      (setq message "The subject has papers, first delete them and try again.")))
													  (create-menubar)
													  (grid-columnconfigure *tk* 0 :weight 1) 
													  (grid-rowconfigure *tk* 0 :weight 1)
													  (destroy *school-info-main-frame*)
													  (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
													  (grid *school-info-main-frame* 0 0)
													  (grid (make-instance 'label :master *school-info-main-frame* :text message) 1 0))
													)))))))))))
(defun house-menu (house-menu)
  (make-instance 'menubutton :master house-menu :text "New" :command (lambda () (house-form)))
  (let ((edit-menu (make-instance 'menu :master house-menu :text "Edit"))
	(delete-menu (make-instance 'menu :master house-menu :text "Delete"))
	(houses (|get-house|)))
    (dolist (house houses)
      (make-instance 'menubutton :master edit-menu :text (cadr house) :command (lambda () (house-form house)))
      (make-instance 'menubutton :master delete-menu :text (cadr house)
				 :command (lambda ()
					    (let ((message-text "House has been deleted."))
					      (handler-case (|delete-house| (car house))
						(sqlite-constraint-error (err)
						  (declare (ignorable err))
						  (setq message-text "House can't be deleted as it has data depending on it, first delete them and try again.")))
					      (create-menubar)
					      (grid-columnconfigure *tk* 0 :weight 1) 
					      (grid-rowconfigure *tk* 0 :weight 1)
					      (destroy *school-info-main-frame*)
					      (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
					      (grid *school-info-main-frame* 0 0)
					      (grid (make-instance 'label :master *school-info-main-frame* :text message-text) 1 0)))))))

(defun dorm-menu (dorm-menu)
  (make-instance 'menubutton :master dorm-menu :text "New" :command (lambda () (dorm-form)))
  (let ((edit-menu (make-instance 'menu :master dorm-menu :text "Edit"))
	(delete-menu (make-instance 'menu :master dorm-menu :text "Delete"))
	(dorms (|get-dorm|)))
    (dolist (dorm dorms)
      (make-instance 'menubutton :master edit-menu :text (cadr dorm) :command (lambda () (dorm-form dorm)))
      (make-instance 'menubutton :master delete-menu :text (cadr dorm)
				 :command (lambda ()
					    (let ((message-text "Dorm has been deleted."))
					      (handler-case (|delete-dorm| (car dorm))
						(sqlite-constraint-error (err)
						  (declare (ignorable err))
						  (setq message-text "Dorm can't be deleted as it has data depending on it, first delete them and try again.")))
					      (create-menubar)
					      (grid-columnconfigure *tk* 0 :weight 1) 
					      (grid-rowconfigure *tk* 0 :weight 1)
					      (destroy *school-info-main-frame*)
					      (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
					      (grid *school-info-main-frame* 0 0)
					      (grid (make-instance 'label :master *school-info-main-frame* :text message-text) 1 0)))))))

(defun create-menubar ()
  "create a new menu bar, if an old one exists, destroy it, then recreate a new one."
  (when *menubar*
    (destroy *menubar*))
  (setq *menubar* (make-instance 'menubar)) 
  (let* ((level-menu (make-instance 'menu :master *menubar* :text "Levels"))
	 (class-menu (make-instance 'menu :master *menubar* :text "Classes"))
	 (stream-menu (make-instance 'menu :master *menubar* :text "Streams"))
	 (subject-menu (make-instance 'menu :master *menubar* :text "Subjects"))
	 (paper-menu (make-instance 'menu :master *menubar* :text "Papers"))
	 (house-menu (make-instance 'menu :master *menubar* :text "Houses"))
	 (dorm-menu (make-instance 'menu :master *menubar* :text "Dormitories"))
	 )

    (declare (ignorable paper-menu))
    (level-menu level-menu)
    (class-menu class-menu)
    (stream-menu stream-menu)
    (subject-menu subject-menu)
    (house-menu house-menu)
    (dorm-menu dorm-menu)
    ))


(defun start ()
  "start the info application, try to create the tables, bind the error to continue execution if the tables are already present. enable foreign key support on the database"
  (execute-non-query *db* "pragma foreign_keys = on")
  (handler-case
      (create-tables)
    (sqlite-error (err)
      (declare (ignorable err))))
  (with-ltk ()
					; (iconbitmap #p"/home/lam/common-lisp/school/favicon.ico")
    (create-menubar)
    (minsize *tk* 800 600)
    ;; start in maximized on OSX and Windows
    (unless (equal "Linux" (software-type))
      (setf (wm-state *tk*) 'zoomed))
    (wm-title *tk* "School Info")
    ))

(defun level-form (&optional level)
  "collect and process data about levels
   (= level (cons id level))"
  (unless (null *school-info-main-frame*)
    (ltk:destroy *school-info-main-frame*))
  (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
  (let* (
	 (level-label (make-instance 'label :master *school-info-main-frame* :text "Enter Level Name"))
	 (level-entry (make-instance 'entry :master *school-info-main-frame* :text (cadr level)))
	 (save-button (make-instance 'button :master *school-info-main-frame*
					     :text "Save Level" :command (lambda ()
									   (if level
									       (|update-level| (car level) (text level-entry))
									       (|save-level| (text level-entry)))
									   (create-menubar)
									   (destroy *school-info-main-frame*)
									   (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
									   (grid *school-info-main-frame* 0 0)
									   (grid (make-instance 'label :master *school-info-main-frame* :text "The level has been saved.") 1 0)))))
    (prepare-main-window)
    (grid  level-label 1 0 :padx 10 :pady 5)
    (grid level-entry 1 2 :padx 10 :pady 5 :sticky "e" :columnspan 5)
    (grid save-button 2 2 :pady 10)))

(defun house-form (&optional house)
  "collect and process data about houses
   (= house (cons id house))"
  (unless (null *school-info-main-frame*)
    (ltk:destroy *school-info-main-frame*))
  (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
  (let* (
	 (house-label (make-instance 'label :master *school-info-main-frame* :text "Enter House Name"))
	 (house-entry (make-instance 'entry :master *school-info-main-frame* :text (cadr house)))
	 (save-button (make-instance 'button :master *school-info-main-frame*
					     :text "Save House" :command (lambda ()
									   (if house
									       (|update-house| (car house) (text house-entry))
									       (|save-house| (text house-entry)))
									   (create-menubar)
									   (destroy *school-info-main-frame*)
									   (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
									   (grid *school-info-main-frame* 0 0)
									   (grid (make-instance 'label :master *school-info-main-frame* :text "The house has been saved.") 1 0)))))
    (prepare-main-window)
    (grid  house-label 1 0 :padx 10 :pady 5)
    (grid house-entry 1 2 :padx 10 :pady 5 :sticky "e" :columnspan 5)
    (grid save-button 2 2 :pady 10)))


(defun dorm-form (&optional dorm)
  "collect and process data about dorms
   (= dorm (cons id dorm))"
  (unless (null *school-info-main-frame*)
    (ltk:destroy *school-info-main-frame*))
  (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
  (let* (
	 (dorm-label (make-instance 'label :master *school-info-main-frame* :text "Enter Dorm Name"))
	 (dorm-entry (make-instance 'entry :master *school-info-main-frame* :text (cadr dorm)))
	 (save-button (make-instance 'button :master *school-info-main-frame*
					     :text "Save Dorm" :command (lambda ()
									  (if dorm
									      (|update-dorm| (car dorm) (text dorm-entry))
									      (|save-dorm| (text dorm-entry)))
									  (create-menubar)
									  (destroy *school-info-main-frame*)
									  (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
									  (grid *school-info-main-frame* 0 0)
									  (grid (make-instance 'label :master *school-info-main-frame* :text "The dorm has been saved.") 1 0)))))
    (prepare-main-window)
    (grid  dorm-label 1 0 :padx 10 :pady 5)
    (grid dorm-entry 1 2 :padx 10 :pady 5 :sticky "e" :columnspan 5)
    (grid save-button 2 2 :pady 10)))

(defun class-form (&optional level-id class-text)
  "collect and process data about classes
   the form has a combobox list of levels to choose from, shows an error if no levels are present."
  (let ((levels (|get-level|)))   
    (unless (null *school-info-main-frame*)
      (ltk:destroy *school-info-main-frame*))
    (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
    (if levels
	(let* (
	       (level-label (make-instance 'label :master *school-info-main-frame* :text "Select Level"))
	       (level-combobox (make-instance 'combobox :text (caar levels) :master *school-info-main-frame* :values (mapcar (lambda (x) (car x)) levels)))
	       (class-label (make-instance 'label :master *school-info-main-frame* :text "Enter Class Name"))
	       (class-entry (make-instance 'entry :master *school-info-main-frame* :text class-text))
	       (save-button (make-instance 'button :master *school-info-main-frame*
						   :text "Save Class" :command (lambda ()
										 (if class-text
										     (update-class level-id class-text (text class-entry))
										     (save-class (get-level-id (text level-combobox)) (text class-entry)))
										 (create-menubar)
										 (destroy *school-info-main-frame*)
										 (format *standard-output* "~a" (text level-combobox))
										 (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
										 (grid *school-info-main-frame* 0 0)
										 (grid (make-instance 'label :master *school-info-main-frame* :text "The class has been saved.") 1 0)))))
	  (prepare-main-window)
	  (grid level-label 0 0 :padx 10 :pady 5)
	  (grid level-combobox 0 2 :padx 10 :pady 5)
	  (grid class-label 1 0 :padx 10 :pady 5)
	  (grid class-entry 1 2 :padx 10 :pady 5 :sticky "e" :columnspan 5)
	  (grid save-button 2 2 :pady 10))
	(let ((error-text (make-instance 'label :master *school-info-main-frame* :text "There are no levels, first create a level to continue.")))
	  (prepare-main-window)
	  (grid error-text 0 0 :padx 10 :pady 5))
	)))

(defun stream-form (&optional class-text stream-text )
  "collect and process data about streams. includes a combobox for selecting a class, every stream should be part of a class."
  (let ((classes (get-classes)))
    (unless (null *school-info-main-frame*)
      (ltk:destroy *school-info-main-frame*))
    (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
    (if classes
	(let* (
	       (class-label (make-instance 'label :master *school-info-main-frame* :text "Choose Class Name"))
	       (class-combobox (make-instance 'combobox :text (caar classes) :master *school-info-main-frame* :values (mapcar (lambda (x) (car x)) classes)))
	       (stream-label (make-instance 'label :master *school-info-main-frame* :text "Enter Stream Name"))
	       (stream-entry (make-instance 'entry :master *school-info-main-frame* :text stream-text))
	       (save-button (make-instance 'button :master *school-info-main-frame*
						   :text "Save Stream" :command (lambda ()
										  (if stream-text
										      (update-stream (get-class-id class-text) stream-text (text stream-entry))
										      (save-stream (get-class-id (text class-combobox)) (text stream-entry)))
										  (create-menubar)
										  (destroy *school-info-main-frame*)
										  (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
										  (grid *school-info-main-frame* 0 0)
										  (grid (make-instance 'label :master *school-info-main-frame* :text "The stream has been saved.") 1 0)))))
	  (prepare-main-window)
	  (grid class-label 1 0 :padx 10 :pady 5)
	  (grid class-combobox 1 2 :padx 10 :pady 5 :sticky "e" :columnspan 5)
	  (grid stream-label 2 0 :padx 10 :pady 5)
	  (grid stream-entry 2 1 :padx 10 :pady 5 :sticky "e" :columnspan 5)
	  (grid save-button 3 2 :pady 10))
	(let ((error-text (make-instance 'label :master *school-info-main-frame* :text "There are no classes, first create a class to add stream to.")))
	  (prepare-main-window)
	  (grid error-text 0 0 :padx 10 :pady 5))
	)))

(defun subject-form (stream-data &optional subject-data)
  "create a new subject; (= stream-data (cons stream stream_id class_id))
   (= subject-data (cons subject_id subject"
  (let ((class (get-class-name (cadr stream-data)))
	(stream (car stream-data))
	(stream-id (cadr stream-data))
	(levels (|get-level|))
	(subject-name (cadr subject-data))
	(subject-id (car subject-data)))
    (unless (null *school-info-main-frame*)
      (ltk:destroy *school-info-main-frame*))
    (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
    (if levels
	(let* (
	       (class-label (make-instance 'label :master *school-info-main-frame* :text "Class"))
	       (class-entry (make-instance 'entry :master *school-info-main-frame* :text class :state :disabled))
	       (stream-label (make-instance 'label :master *school-info-main-frame* :text "Stream"))
	       (stream-entry (make-instance 'entry :master *school-info-main-frame* :text stream :state :disabled))
	       (subject-label (make-instance 'label :master *school-info-main-frame* :text "Enter Subject"))
	       (subject-entry (make-instance 'entry :master *school-info-main-frame* :text subject-name))
	       (save-button (make-instance 'button :master *school-info-main-frame*
						   :text "Save Subject" :command (lambda ()
										   (if subject-name
										       (update-subject subject-id (text subject-entry))
										       (save-subject stream-id (text subject-entry))
										       )
										   (create-menubar)
										   (destroy *school-info-main-frame*)
										   (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
										   (grid *school-info-main-frame* 0 0)
										   (grid (make-instance 'label :master *school-info-main-frame* :text "The subject has been saved.") 1 0))))
	       )
	  (prepare-main-window)
	  (grid class-label 0 0 :padx 10 :pady 5)
	  (grid class-entry 0 2 :padx 10 :pady 5)
	  (grid stream-label 1 0 :padx 10 :pady 5)
	  (grid stream-entry 1 2 :padx 10 :pady 5)
	  (grid subject-label 2 0 :padx 10 :pady 5)
	  (grid subject-entry 2 2 :padx 10 :pady 5)
	  (grid save-button 3 2 :pady 10))
	(let ((error-text (make-instance 'label :master *school-info-main-frame* :text "There are no levels, first create a level to continue.")))
	  (prepare-main-window)
	  (grid error-text 0 0 :padx 10 :pady 5))
	)))

(defun show-stream-subjects (stream-data)
  "get and display all subjects for a particular stream"
  (let ((stream-subjects (get-stream-subjects (cadr stream-data))))
    (unless (null *school-info-main-frame*)
      (ltk:destroy *school-info-main-frame*))
    (setq *school-info-main-frame* (make-instance 'frame :borderwidth 5 :relief :ridge))
    (if stream-subjects
	(let* ((subjects-label (make-instance 'label :master *school-info-main-frame* :text (format nil "Subjects for ~a - ~a" (get-class-name (caddr stream-data)) (car stream-data))))
	       (subject-listbox (make-instance 'listbox :master *school-info-main-frame*)))
	  (prepare-main-window)
	  (listbox-append subject-listbox (mapcar #'cadr stream-subjects))
	  (grid subjects-label 0 0 :padx 10 :pady 5)
	  (grid subject-listbox 1 0 :padx 10 :pady 5))
	(let ((error-text (make-instance 'label :master *school-info-main-frame* :text (format nil "There are no subjects for ~a ~a." (cadr stream-data) (car stream-data)))))
	  (prepare-main-window)
	  (grid error-text 0 0 :padx 10 :pady 5))
	)))
